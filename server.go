package main

import (
	"github.com/patrickmamaid/go_grpc/chat"
	"google.golang.org/grpc"
	"log"
	"net"
)

// main()
// the intent here is to run a server on 9000
// to serve the chat.* ability we created with protobuf protoc grpc within the package chat
func main() {

	// @@@@@@@<<<<<<<<<<<<<<<<< CONNECTION PREPARATION >>>>>>>>>>>>>>>>>@@@@@@@@@@@

	// we will configure a Listen object here with proto tcp and port 9000
	// we use net.Listen() because it returns a configured "Listener"
	// the "Listen" aka lis, will be used in the grpcServer.Serve(lis) later
	lis, err := net.Listen("tcp", ":9000")
	if err != nil {
		log.Fatalf("Failed to listen on port 9000: %v", err)
	}

	// init the (blank struct) chat "server"
	// this has methods like SayHello attached to it
	s := chat.Server{}

	// the actual grpc server grpcServer
	grpcServer := grpc.NewServer()

	// chat.RegisterChatServiceServer(grpcServer, &s) is a NON blocking command
	// chat.RegisterChatServiceServer method comes from the autogenerated chat_grpc.pb.go by protoc
	// this line essentially tells protobuf that: I want to register the chatserver and gprc server together (grpcServer, &s)
	chat.RegisterChatServiceServer(grpcServer, &s)
	// after registering, the SayHello() it is then offered to clients, as a server you DO NOT need to manually register the SayHello() itself
	// because of : s := chat.Server{}

	// @@@@@@@<<<<<<<<<<<<<<<<< END PREPARATION >>>>>>>>>>>>>>>>>@@@@@@@@@@@

	// grpcServer.Serve(lis) is a BLOCKING command
	// this line runs the grpc service on port 9000 and waits for connections indefinitley
	if err := grpcServer.Serve(lis); err != nil {
		log.Fatalf("Failed to serve gRPC server over port 9000: %v", err)
	}
}
